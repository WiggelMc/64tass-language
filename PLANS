
let the server do everything thats not editor changes
let the client initialize everything (send file contents) thats open in the editor (maybe only incremental changes)

-----------------------------------------

incremental change processing (only needed for changes in the editor) [figure out how]


open files are stored in a map and will be ignored in fs updates

When a file is opened, the version and lines are stored (lines into array)


2 options:
    always calculate syntax highlighting (faster load when opening a file, slower indexing, more memory)
        indexing will only happen once
            

    only calculate syntax highlighting when open (slower load when opening a file, faster indexing, less memory)
        complete file will be parsed again when opened (only definitions, includes, scopes, etc are stored)


How to store data about a file [needs thinking]
how much should a textmate grammar be used (if at all)
how to implement different instruction sets
    provide different language for each processor (instant highlighting / language has to be selected somehow)
    highlight all instructions by default (instant highlighting / confusing for a second if unsupported instruction is used)
    highlight no instructions by default (not instant highlighting / no confusion)


TextMate
	data (string number boolean)
	operators (+)
	Other (* , ?)
Dynamic
	Symbols
	anonymous symbols (+)
	INSTRUCTIONS
	filepath/name
	compiler directives (.scope)
	builtin functions (ceil)

-----------------------

TODO

Find way to detect processor used (maybe use all in order)
    manual selection
    detect from source file (.cpu)
    detect from task [complicated / maybe not]
        task run
        task files
        

Test how syntax highlighting works in git/override diff

Find a way to
    Update the Semantic Highlights for a file (open file only) [found for all files]
    



maybe use codeLens
    to show information from list file next to source Code
    to show scope of a function or section
    




How can a line look???

; comment is ignored anyway

definitions[
	params:	List of (expressions|variables|assignments) (comma seperated)
	expression: Combination of operators and value types
]

[Label] .directive [params]
[Label] opcode [params]
Variable assignment_operator expression




Indexing

	File Update
		config?

	Editor Update


	Semantic Request





########################################

Stuff to investigate (implement)

############################################

selection Range			V
code action				V

document hightlight			i
(document formatting)		i
document links			V
(folding ranges)		V
linked editing range	V

rename					V
execute Command			V

custom:
	list-file			V
	decorations				i


definition / declaration / implementation / type definition / references





####################################################################################################################
####################################################################################################################
####################################################################################################################


OLD PLANS


####################################################################################################################
####################################################################################################################
####################################################################################################################


syntax highlighting
	good categorisation
	multiple color schemes
	unary / binary operator detection
	variable highlighting (only if defined)

functions labels variables macros
	goto definition
	definition popup
	type inference
		show properties of defined structs / scopes like in java 
	show structure of file in OUTLINE tab (bottom left)
	
useful autocomplete
	show adressing modes when typing instruction
	allow toggling of instruction set in options (+allow custom instruction sets)
		json files with instructions (adressing modes => cycles [notes], bytes [notes])
		adressing modes are also defined in a json file
		allow for composition of files (eg include list)
	only autocomplete defined variables, functions, etc and show type in preview bar


listing file support [Indexing the list file on change will make navigation easier]
	listing file popup
	goto line in listing file (from source)
	goto line in source (from listing file)


Show information beside code (cascading properties)
	register size

Add Breakpoint via click
	and only show breakpoint dot (hide the lines [optional])

Workspace setup command
	Will set options and directories to premade Workspace


Make every keyword and symbol configurable
	this includes order of operations and specific behavior
	this will make supporting later version easier
	old configs can be kept for lagacy support (maybe add an option)

Always assume global scope (one way) in functions macros, unused or multi included files
	a comment in the format somewhere in the file or function will assume the scope (maybe only on function definition / first line of file)
	
	; file_scope = Bank80
	; section_scope = Bank80.Main

Scope Indexing
	

CONFIG FILES:

idea 1
	SYNTAX
		64tass-1.56.2625.json
	INSTRUCTIONS
		6502.json
		65c02.json
		65ce02.json
		6502i.json
		65816.json
		65dtv02.json
		65el02.json
		r65c02.json
		w65c02.json
		4510.json


idea 2
	V1-56-2625
		syntax.json

		INSTRUCTIONS
			6502.json
			65c02.json
			65ce02.json
			6502i.json
			65816.json
			65dtv02.json
			65el02.json
			r65c02.json
			w65c02.json
			4510.json

OPTIONS:

	COMPILER:
	[9]	instruction-set: string
		case-sensitive: bool (true) (can be on, even if the command line option is off)
	[2]	tasm-compatible: bool (false)
		include-search-path: string[]
		master-file: string
		list-file: string
		assemble-task: string ("ASSEMBLE")
		

	INTERFACE:
		??


	KEYBOARD:
		viewInList
		assembleAndViewInList
		viewInSource










Properties of a single line

require [variable]
define/assign [variable]
open/close [scope]
set cascading property [register size]





Specifics

Define Variable

LABEL ADC / nothing

OBJ .byte / .word / .long / .dstruct <> / .dunion <> [is always a label too]

TYPE .struct / .union [are scopes when named, visible otherwise]

SCOPE .proc / .block / .namespace <> / .weak / .binclude  [is always a label too] [will be inaccessible if not named]
		activate scope: .with <> / .namespace <>

CONST = 
VAR :=
VAR .var
.dsection SECTION
		use section: .section

MACRO .segment / .macro
FUNCTION .function


.if / .elsif
.switch / .case

.for /.bfor / .rept / .brept / .while / .bwhile / .break /.breakif / .continue / .continueif / ...

.comment / ;


address	Address type
bits	Bit string type
bool	Boolean type
bytes	Byte string type
code	Code type
dict	Dictionary type
float	Floating point type
gap	Uninitialized memory type (? Symbol)
int	Integer type
list	List type
str	Character string type
tuple	Tuple type
type	Type type